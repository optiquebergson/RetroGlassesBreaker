import React, { useState, useEffect, useRef } from 'react';

const RetroGlassesBreaker = () => {
  const canvasRef = useRef(null);
  const containerRef = useRef(null);
  const requestRef = useRef(null);

  const [gameState, setGameState] = useState('email'); // email / playing / levelComplete / gameOver / won
  const [level, setLevel] = useState(1);
  const [score, setScore] = useState(0);
  const [lives, setLives] = useState(3);
  const [showBrokenGlasses, setShowBrokenGlasses] = useState(false);
  const [confetti, setConfetti] = useState([]);
  const [canvasSize, setCanvasSize] = useState({ width: 800, height: 600 });

  const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

  const PADDLE_WIDTH = 100;
  const PADDLE_HEIGHT = 20;
  const BALL_SIZE = 30;
  const BRICK_COLS = 8;
  const BRICK_PADDING = 5;
  const LETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  const BRICK_COLORS = [
    '#FF006E', '#8338EC', '#3A86FF', '#FB5607',
    '#FFBE0B', '#06FFA5', '#FF006E', '#8338EC'
  ];

  const gameRef = useRef({
    paddle: { x: 0, y: 0, width: PADDLE_WIDTH, height: PADDLE_HEIGHT },
    ball: { x: 0, y: 0, dx: 4, dy: -4, size: BALL_SIZE },
    bricks: [],
    keys: {},
    mouseX: 0,
    touchX: null,
    ballLaunched: false
  });

  // Canvas responsive
  useEffect(() => {
    const updateSize = () => {
      const maxWidth = window.innerWidth - 20;
      const maxHeight = window.innerHeight * 0.7;
      const aspectRatio = 800 / 600;
      let width = maxWidth;
      let height = width / aspectRatio;
      if (height > maxHeight) {
        height = maxHeight;
        width = height * aspectRatio;
      }
      setCanvasSize({ width: Math.floor(width), height: Math.floor(height) });
    };
    updateSize();
    window.addEventListener('resize', updateSize);
    return () => window.removeEventListener('resize', updateSize);
  }, []);

  // Initialize bricks
  const initBricks = () => {
    const bricks = [];
    const rows = 5 + level;
    const brickWidth = (canvasSize.width - 70) / BRICK_COLS - BRICK_PADDING;
    const brickHeight = 30;
    const offsetTop = 80;
    const offsetLeft = 35;
    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < BRICK_COLS; col++) {
        const health = level === 4 ? 2 : 1;
        bricks.push({
          x: offsetLeft + col * (brickWidth + BRICK_PADDING),
          y: offsetTop + row * (brickHeight + BRICK_PADDING),
          width: brickWidth,
          height: brickHeight,
          health,
          maxHealth: health,
          letter: LETTERS[Math.floor(Math.random() * LETTERS.length)],
          color: BRICK_COLORS[col % BRICK_COLORS.length],
          visible: true
        });
      }
    }
    return bricks;
  };

  const initGame = () => {
    const game = gameRef.current;
    game.paddle.x = canvasSize.width / 2 - PADDLE_WIDTH / 2;
    game.paddle.y = canvasSize.height - 40;
    game.ball.x = canvasSize.width / 2;
    game.ball.y = canvasSize.height - 60;
    game.ball.dx = 4 + level * 0.5;
    game.ball.dy = -(4 + level * 0.5);
    game.mouseX = canvasSize.width / 2;
    game.touchX = null;
    game.bricks = initBricks();
    game.ballLaunched = false;
  };

  // Confetti
  const createConfetti = () => {
    const newConfetti = [];
    for (let i = 0; i < 150; i++) {
      newConfetti.push({
        x: Math.random() * canvasSize.width,
        y: -10,
        vx: (Math.random() - 0.5) * 4,
        vy: Math.random() * 3 + 2,
        color: BRICK_COLORS[Math.floor(Math.random() * BRICK_COLORS.length)],
        size: Math.random() * 8 + 4,
        rotation: Math.random() * 360
      });
    }
    setConfetti(newConfetti);
  };

  useEffect(() => {
    if (gameState === 'won' && confetti.length > 0) {
      const interval = setInterval(() => {
        setConfetti(prev =>
          prev.map(c => ({ ...c, x: c.x + c.vx, y: c.y + c.vy, rotation: c.rotation + 5 }))
            .filter(c => c.y < canvasSize.height)
        );
      }, 30);
      return () => clearInterval(interval);
    }
  }, [gameState, confetti.length, canvasSize.height]);

  // Game loop
  useEffect(() => {
    if (gameState === 'playing') {
      const canvas = canvasRef.current;
      const ctx = canvas.getContext('2d');

      const handleKeyDown = e => {
        gameRef.current.keys[e.key] = true;
        if (e.key === ' ' && !gameRef.current.ballLaunched) gameRef.current.ballLaunched = true;
      };
      const handleKeyUp = e => gameRef.current.keys[e.key] = false;

      const handleMouseMove = e => {
        const rect = canvas.getBoundingClientRect();
        gameRef.current.mouseX = (e.clientX - rect.left) * (canvasSize.width / rect.width);
      };

      const handleTouchStart = e => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const touch = e.touches[0];
        gameRef.current.touchX = (touch.clientX - rect.left) * (canvasSize.width / rect.width);
        if (!gameRef.current.ballLaunched) gameRef.current.ballLaunched = true;
      };
      const handleTouchMove = e => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const touch = e.touches[0];
        gameRef.current.touchX = (touch.clientX - rect.left) * (canvasSize.width / rect.width);
      };
      const handleTouchEnd = e => { e.preventDefault(); gameRef.current.touchX = null; };

      window.addEventListener('keydown', handleKeyDown);
      window.addEventListener('keyup', handleKeyUp);
      canvas.addEventListener('mousemove', handleMouseMove);
      canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
      canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
      canvas.addEventListener('touchend', handleTouchEnd, { passive: false });

      const gameLoop = () => {
        update();
        draw(ctx);
        requestRef.current = requestAnimationFrame(gameLoop);
      };
      gameLoop();

      return () => {
        window.removeEventListener('keydown', handleKeyDown);
        window.removeEventListener('keyup', handleKeyUp);
        canvas.removeEventListener('mousemove', handleMouseMove);
        canvas.removeEventListener('touchstart', handleTouchStart);
        canvas.removeEventListener('touchmove', handleTouchMove);
        canvas.removeEventListener('touchend', handleTouchEnd);
        if (requestRef.current) cancelAnimationFrame(requestRef.current);
      };
    }
  }, [gameState, level, lives, canvasSize]);

  // Update game
  const update = () => {
    const game = gameRef.current;

    if (game.keys['ArrowLeft']) game.paddle.x -= 8;
    if (game.keys['ArrowRight']) game.paddle.x += 8;

    const targetX = game.touchX !== null ? game.touchX : game.mouseX;
    game.paddle.x = Math.max(0, Math.min(canvasSize.width - game.paddle.width, targetX - game.paddle.width / 2));

    if (game.ballLaunched) {
      game.ball.x += game.ball.dx;
      game.ball.y += game.ball.dy;

      if (game.ball.x <= 0 || game.ball.x >= canvasSize.width - game.ball.size) game.ball.dx = -game.ball.dx;
      if (game.ball.y <= 0) game.ball.dy = -game.ball.dy;

      // Paddle collision
      if (
        game.ball.y + game.ball.size >= game.paddle.y &&
        game.ball.y <= game.paddle.y + game.paddle.height &&
        game.ball.x + game.ball.size >= game.paddle.x &&
        game.ball.x <= game.paddle.x + game.paddle.width
      ) {
        game.ball.dy = -Math.abs(game.ball.dy);
        const hitPos = (game.ball.x - game.paddle.x) / game.paddle.width;
        game.ball.dx = (hitPos - 0.5) * 10;
      }

      // Bricks collision
      game.bricks.forEach(brick => {
        if (brick.visible &&
          game.ball.x + game.ball.size > brick.x &&
          game.ball.x < brick.x + brick.width &&
          game.ball.y + game.ball.size > brick.y &&
          game.ball.y < brick.y + brick.height
        ) {
          game.ball.dy = -game.ball.dy;
          brick.health--;
          if (brick.health <= 0) { brick.visible = false; setScore(s => s + level * 10); }
        }
      });

      if (game.ball.y > canvasSize.height) {
        setShowBrokenGlasses(true);
        setTimeout(() => setShowBrokenGlasses(false), 1500);

        setLives(l => {
          const newLives = l - 1;
          if (newLives <= 0) setGameState('gameOver');
          else {
            game.ball.x = canvasSize.width / 2;
            game.ball.y = canvasSize.height - 60;
            game.ball.dx = 4 + level * 0.5;
            game.ball.dy = -(4 + level * 0.5);
            game.ballLaunched = false;
          }
          return newLives;
        });
      }
    } else {
      game.ball.x = game.paddle.x + game.paddle.width / 2 - game.ball.size / 2;
    }

    if (game.bricks.every(b => !b.visible)) {
      if (level === 4) { createConfetti(); setGameState('won'); }
      else setGameState('levelComplete');
    }
  };

  // Draw game
  const draw = (ctx) => {
    const game = gameRef.current;
    ctx.clearRect(0, 0, canvasSize.width, canvasSize.height);

    const gradient = ctx.createLinearGradient(0, 0, 0, canvasSize.height);
    gradient.addColorStop(0, '#1a0033');
    gradient.addColorStop(1, '#0d001a');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvasSize.width, canvasSize.height);

    ctx.strokeStyle = 'rgba(138, 43, 226, 0.1)';
    ctx.lineWidth = 1;
    for (let i = 0; i < canvasSize.width; i += 40) { ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, canvasSize.height); ctx.stroke(); }
    for (let i = 0; i < canvasSize.height; i += 40) { ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(canvasSize.width, i); ctx.stroke(); }

    // Bricks
    game.bricks.forEach(brick => {
      if (!brick.visible) return;
      ctx.fillStyle = brick.color;
      ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.strokeRect(brick.x, brick.y, brick.width, brick.height);
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 20px "Courier New", monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(brick.letter, brick.x + brick.width / 2, brick.y + brick.height / 2);
      if (brick.health < brick.maxHealth) { ctx.fillStyle = 'rgba(255,255,255,0.5)'; ctx.fillRect(brick.x, brick.y, brick.width, brick.height); }
    });

    // Paddle
    ctx.fillStyle = '#00ff00';
    ctx.fillRect(game.paddle.x, game.paddle.y, game.paddle.width, game.paddle.height);
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.strokeRect(game.paddle.x, game.paddle.y, game.paddle.width, game.paddle.height);

    // Ball
    ctx.fillStyle = '#ffff00';
    ctx.beginPath();
    ctx.arc(game.ball.x + game.ball.size / 2, game.ball.y + game.ball.size / 2, 8, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#fff';
    ctx.stroke();

    // HUD
    ctx.fillStyle = '#00ffff';
    ctx.font = 'bold 20px "Courier New", monospace';
    ctx.textAlign = 'left';
    ctx.fillText(`NIVEAU: ${level}`, 20, 30);
    ctx.fillText(`SCORE: ${score}`, 20, 55);
    ctx.fillText(`VIES: ${'❤️'.repeat(lives)}`, canvasSize.width - 150, 30);

    if (!game.ballLaunched) {
      ctx.fillStyle = '#ffff00';
      ctx.font = `bold ${isMobile ? '14' : '16'}px "Courier New", monospace`;
      ctx.textAlign = 'center';
      ctx.fillText(isMobile ? 'TOUCHE L\'ÉCRAN POUR LANCER' : 'ESPACE OU CLIC POUR LANCER',
        canvasSize.width / 2, canvasSize.height / 2
      );
    }
  };

  const nextLevel = () => { setLevel(l => l + 1); setGameState('playing'); initGame(); };
  const restartGame = () => { setLevel(1); setScore(0); setLives(3); setGameState('playing'); initGame(); };
  const handleCanvasClick = () => { if (gameState === 'playing' && !gameRef.current.ballLaunched) gameRef.current.ballLaunched = true; };

  return (
    <div className="flex items-center justify-center min-h-screen bg-gradient-to-br from-purple-900 via-indigo-900 to-black p-4" ref={containerRef}>
      {showBrokenGlasses && (
        <div className="fixed inset-0 flex items-center justify-center z-50 pointer-events-none">
          <div className="bg-black bg-opacity-80 p-8 rounded-lg animate-pulse">
            <p className="text-red-500 text-2xl font-bold text-center">CASSÉES !</p>
          </div>
        </div>
      )}
      <canvas
        ref={canvasRef}
        width={canvasSize.width}
        height={canvasSize.height}
        onClick={handleCanvasClick}
        className="border-4 border-cyan-400 rounded-lg shadow-2xl cursor-pointer mx-auto touch-none"
        style={{ width: '100%', height: 'auto' }}
      />
    </div>
  );
};

export default RetroGlassesBreaker;
